--==============================================================================
--                         COREX GUI V1.7 - MOVEMENT MODULE
--==============================================================================

local CoreX = _G.CoreXShared
if not CoreX then error("CoreX core not loaded!") return end

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer

local Colors = CoreX.Colors
local Actions = CoreX.Actions
local toggleStates = CoreX.toggleStates
local toggleSetters = CoreX.toggleSetters

-- Movement State
Actions._speedEnabled = false
Actions._speedValue = 50
Actions._origWalkSpeed = nil
Actions._jumpEnabled = false
Actions._jumpValue = 50
Actions._origJumpHeight = nil
Actions._origJumpPower = nil
Actions._infJumpEnabled = false
Actions._fovEnabled = false
Actions._fovValue = 70
Actions._flyEnabled = false
Actions._flySpeed = 100
Actions._noclipEnabled = false
Actions._noclipConn = nil
Actions._desyncCamEnabled = false
Actions._desyncCamConn = nil
Actions._desyncCamCFrame = nil

local flyKeys = {W = false, A = false, S = false, D = false, Q = false, E = false, Shift = false}

-- Helper functions
local function getChar() return player.Character end
local function getHumanoid() local c = getChar() return c and c:FindFirstChildOfClass("Humanoid") end
local function getHRP() local c = getChar() return c and c:FindFirstChild("HumanoidRootPart") end
local function forceUnanchor() local h = getHRP() if h then h.Anchored = false end end

-- Instant Movement Physics
local function applyInstantMovement(hum)
	if not hum then return end
	pcall(function()
		local char = hum.Parent
		if char then
			local hrp = char:FindFirstChild("HumanoidRootPart")
			if hrp then
				hrp.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0, 0, 100, 0)
			end
			for _, part in ipairs(char:GetDescendants()) do
				if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
					pcall(function()
						part.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0, 0, 100, 0)
					end)
				end
			end
		end
	end)
end

local function removeInstantMovement(hum)
	if not hum then return end
	pcall(function()
		local char = hum.Parent
		if char then
			for _, part in ipairs(char:GetDescendants()) do
				if part:IsA("BasePart") then
					pcall(function()
						part.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0.3, 0.5, 1, 1)
					end)
				end
			end
		end
	end)
end

-- Noclip
local function enableNoclip()
	if Actions._noclipConn then Actions._noclipConn:Disconnect() end
	Actions._noclipConn = RunService.Stepped:Connect(function()
		if not CoreX.scriptEnabled or not Actions._noclipEnabled then return end
		local char = getChar()
		if char then
			for _, part in pairs(char:GetDescendants()) do
				if part:IsA("BasePart") then part.CanCollide = false end
			end
		end
	end)
	table.insert(CoreX.Conns, Actions._noclipConn)
end

local function disableNoclip()
	if Actions._noclipConn then Actions._noclipConn:Disconnect() Actions._noclipConn = nil end
end

-- Camera Desync
local function enableCameraDesync()
	if Actions._desyncCamConn then Actions._desyncCamConn:Disconnect() end
	local hrp = getHRP()
	if hrp then Actions._desyncCamCFrame = hrp.CFrame end
	Actions._desyncCamConn = RunService.RenderStepped:Connect(function()
		if not CoreX.scriptEnabled or not Actions._desyncCamEnabled then return end
		local currentHrp = getHRP()
		if currentHrp and Actions._desyncCamCFrame then
			local cam = Workspace.CurrentCamera
			if cam then
				local offset = cam.CFrame.Position - Actions._desyncCamCFrame.Position
				cam.CFrame = CFrame.new(currentHrp.Position + offset, currentHrp.Position + offset + cam.CFrame.LookVector)
			end
		end
	end)
	table.insert(CoreX.Conns, Actions._desyncCamConn)
end

local function disableCameraDesync()
	if Actions._desyncCamConn then Actions._desyncCamConn:Disconnect() Actions._desyncCamConn = nil end
	Actions._desyncCamCFrame = nil
end

-- Infinite Jump
table.insert(CoreX.Conns, UserInputService.JumpRequest:Connect(function()
	if CoreX.scriptEnabled and Actions._infJumpEnabled then
		local hum = getHumanoid()
		if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
	end
end))

-- Fly key handler
local function setFlyKey(keyCode, isDown)
	local map = {
		[Enum.KeyCode.W] = "W", [Enum.KeyCode.A] = "A", [Enum.KeyCode.S] = "S", [Enum.KeyCode.D] = "D",
		[Enum.KeyCode.Q] = "Q", [Enum.KeyCode.E] = "E",
		[Enum.KeyCode.LeftShift] = "Shift", [Enum.KeyCode.RightShift] = "Shift"
	}
	if map[keyCode] then flyKeys[map[keyCode]] = isDown end
end

-- Register fly key handlers
if not CoreX.FlyKeysRegistered then
	CoreX.FlyKeysRegistered = true
	CoreX.setFlyKey = setFlyKey -- Expose for input handler
end

-- Fly update (registered in main input handler)
if not CoreX.FlyUpdateRegistered then
	CoreX.FlyUpdateRegistered = true
	CoreX.UpdateFly = function(dt)
		if not Actions._flyEnabled then return end
		local hrp = getHRP()
		if not hrp then return end
		
		hrp.Anchored = true
		local cam = Workspace.CurrentCamera
		local look = cam and cam.CFrame.LookVector or hrp.CFrame.LookVector
		local right = cam and cam.CFrame.RightVector or hrp.CFrame.RightVector
		local up = Vector3.new(0, 1, 0)
		local moveDir = Vector3.zero
		if flyKeys.W then moveDir = moveDir + look end 
		if flyKeys.S then moveDir = moveDir - look end 
		if flyKeys.A then moveDir = moveDir - right end 
		if flyKeys.D then moveDir = moveDir + right end 
		if flyKeys.E then moveDir = moveDir + up end 
		if flyKeys.Q then moveDir = moveDir - up end
		if moveDir.Magnitude > 0 then 
			local speed = Actions._flySpeed * (flyKeys.Shift and 2 or 1) 
			hrp.CFrame = hrp.CFrame + moveDir.Unit * speed * dt 
		end
	end
end

-- Action handlers
function Actions.Speed(on)
	Actions._speedEnabled = on
	local hum = getHumanoid()
	if hum then
		if on then
			if not Actions._origWalkSpeed then Actions._origWalkSpeed = hum.WalkSpeed end
			hum.WalkSpeed = Actions._speedValue
			applyInstantMovement(hum)
		else
			hum.WalkSpeed = Actions._origWalkSpeed or 16
			removeInstantMovement(hum)
		end
	end
end

function Actions.SpeedValue(v)
	Actions._speedValue = math.clamp(tonumber(v) or 50, 16, 500)
	if Actions._speedEnabled then
		local hum = getHumanoid()
		if hum then hum.WalkSpeed = Actions._speedValue end
	end
end

function Actions.Jump(on)
	Actions._jumpEnabled = on
	local hum = getHumanoid()
	if hum then
		if on then
			if hum.UseJumpPower then
				if not Actions._origJumpPower then Actions._origJumpPower = hum.JumpPower end
				hum.JumpPower = Actions._jumpValue
			else
				if not Actions._origJumpHeight then Actions._origJumpHeight = hum.JumpHeight end
				hum.JumpHeight = Actions._jumpValue
			end
		else
			if hum.UseJumpPower then hum.JumpPower = Actions._origJumpPower or 50
			else hum.JumpHeight = Actions._origJumpHeight or 7.2 end
		end
	end
end

function Actions.JumpValue(v)
	Actions._jumpValue = math.clamp(tonumber(v) or 50, 1, 500)
	if Actions._jumpEnabled then
		local hum = getHumanoid()
		if hum then
			if hum.UseJumpPower then hum.JumpPower = Actions._jumpValue
			else hum.JumpHeight = Actions._jumpValue end
		end
	end
end

function Actions.InfJump(on) 
	Actions._infJumpEnabled = on 
end

function Actions.FOV(on)
	Actions._fovEnabled = on
	local cam = Workspace.CurrentCamera
	if cam then cam.FieldOfView = on and Actions._fovValue or 70 end
end

function Actions.FOVValue(v)
	Actions._fovValue = math.clamp(tonumber(v) or 70, 30, 120)
	if Actions._fovEnabled then 
		local cam = Workspace.CurrentCamera 
		if cam then cam.FieldOfView = Actions._fovValue end 
	end
end

function Actions.CFrameFly(on)
	Actions._flyEnabled = on
	if on then
		if Actions._desyncCamEnabled and toggleSetters["CameraDesync"] then 
			toggleSetters["CameraDesync"](false) 
		end
	else 
		forceUnanchor() 
	end
end

function Actions.CFrameFlyValue(v) 
	Actions._flySpeed = math.clamp(tonumber(v) or 100, 1, 500) 
end

function Actions.CameraDesync(on)
	Actions._desyncCamEnabled = on
	if on then
		if Actions._flyEnabled and toggleSetters["CFrameFly"] then
			toggleSetters["CFrameFly"](false)
		end
		enableCameraDesync()
	else
		disableCameraDesync()
	end
end

function Actions.Noclip(on)
	Actions._noclipEnabled = on
	if on then enableNoclip() else disableNoclip() end
end

-- Character respawn handler
table.insert(CoreX.Conns, player.CharacterAdded:Connect(function()
	task.wait(0.3)
	if not CoreX.scriptEnabled then return end
	forceUnanchor()
	if Actions._speedEnabled then
		local hum = getHumanoid()
		if hum then
			hum.WalkSpeed = Actions._speedValue
			applyInstantMovement(hum)
		end
	end
	if Actions._jumpEnabled then
		local hum = getHumanoid()
		if hum then
			if hum.UseJumpPower then hum.JumpPower = Actions._jumpValue
			else hum.JumpHeight = Actions._jumpValue end
		end
	end
	if Actions._noclipEnabled then enableNoclip() end
	if Actions._fovEnabled then 
		local cam = Workspace.CurrentCamera 
		if cam then cam.FieldOfView = Actions._fovValue end 
	end
	if Actions._desyncCamEnabled then enableCameraDesync() end
end))

-- Custom CFrame Fly row with slider and keybind (keybind on right side)
local function createCFrameFlyRowWithKeybind(parent, color)
	local ROW_HEIGHT = 34
	local CORNER_SMALL = 6
	
	local row = Instance.new("Frame")
	row.Size = UDim2.new(1, 0, 0, ROW_HEIGHT)
	row.BackgroundColor3 = Colors.SurfaceLight
	row.BorderSizePixel = 0
	row.ZIndex = 5
	row.Parent = parent
	Instance.new("UICorner", row).CornerRadius = UDim.new(0, CORNER_SMALL)
	
	local box = Instance.new("Frame")
	box.Size = UDim2.new(0, 18, 0, 18)
	box.Position = UDim2.new(0, 8, 0.5, -9)
	box.BackgroundColor3 = Colors.SurfaceLighter
	box.BorderSizePixel = 0
	box.ZIndex = 6
	box.Parent = row
	Instance.new("UICorner", box).CornerRadius = UDim.new(0, 4)
	
	local toggleBtn = Instance.new("TextButton")
	toggleBtn.Size = UDim2.new(0, 90, 1, 0)
	toggleBtn.Position = UDim2.new(0, 32, 0, 0)
	toggleBtn.BackgroundTransparency = 1
	toggleBtn.Font = Enum.Font.GothamBold
	toggleBtn.TextSize = 14
	toggleBtn.TextXAlignment = Enum.TextXAlignment.Left
	toggleBtn.TextColor3 = color or Colors.Text
	toggleBtn.Text = "CFrame Fly"
	toggleBtn.ZIndex = 6
	toggleBtn.Parent = row
	
	-- Slider (moved left to make room for keybind)
	local sliderFrame = Instance.new("Frame")
	sliderFrame.Size = UDim2.new(0, 120, 0, 10)
	sliderFrame.Position = UDim2.new(0, 125, 0.5, -5)
	sliderFrame.BackgroundColor3 = Colors.SurfaceLighter
	sliderFrame.BorderSizePixel = 0
	sliderFrame.ZIndex = 6
	sliderFrame.Parent = row
	Instance.new("UICorner", sliderFrame).CornerRadius = UDim.new(0, 5)
	
	local fill = Instance.new("Frame")
	fill.Size = UDim2.new(0.1, 0, 1, 0)
	fill.BackgroundColor3 = color or Colors.Accent
	fill.BorderSizePixel = 0
	fill.ZIndex = 7
	fill.Parent = sliderFrame
	Instance.new("UICorner", fill).CornerRadius = UDim.new(0, 5)
	
	local valLabel = Instance.new("TextLabel")
	valLabel.Size = UDim2.new(0, 50, 1, 0)
	valLabel.Position = UDim2.new(0, 250, 0, 0)
	valLabel.BackgroundTransparency = 1
	valLabel.Font = Enum.Font.GothamBold
	valLabel.TextSize = 13
	valLabel.TextColor3 = color or Colors.Accent
	valLabel.TextXAlignment = Enum.TextXAlignment.Left
	valLabel.ZIndex = 6
	valLabel.Parent = row
	
	-- Keybind button (right side like Noclip)
	local hotkeyBtn = Instance.new("TextButton")
	hotkeyBtn.Size = UDim2.new(0, 50, 0, 22)
	hotkeyBtn.Position = UDim2.new(1, -58, 0.5, -11)
	hotkeyBtn.BackgroundColor3 = Colors.SurfaceLighter
	hotkeyBtn.BorderSizePixel = 0
	hotkeyBtn.Font = Enum.Font.GothamBold
	hotkeyBtn.TextSize = 11
	hotkeyBtn.TextColor3 = Colors.TextMuted
	hotkeyBtn.Text = "Key"
	hotkeyBtn.ZIndex = 6
	hotkeyBtn.Parent = row
	Instance.new("UICorner", hotkeyBtn).CornerRadius = UDim.new(0, 4)
	
	CoreX.hotkeyButtons["CFrameFly"] = hotkeyBtn
	hotkeyBtn.MouseButton1Click:Connect(function()
		CoreX.captureForActionId = "CFrameFly"
		hotkeyBtn.Text = "..."
		hotkeyBtn.TextColor3 = Colors.AccentPink
	end)
	
	local current = 100
	local active = false
	
	local function updateSlider()
		local alpha = (current - 1) / (500 - 1)
		fill.Size = UDim2.new(math.clamp(alpha, 0, 1), 0, 1, 0)
		valLabel.Text = tostring(math.floor(current))
	end
	
	local function setToggle(on)
		if not CoreX.scriptEnabled then return end
		active = on
		toggleStates["CFrameFly"] = on
		box.BackgroundColor3 = on and (color or Colors.Accent) or Colors.SurfaceLighter
		if Actions.CFrameFly then Actions.CFrameFly(on) end
	end
	
	local function setSliderFromX(x)
		local alpha = math.clamp((x - sliderFrame.AbsolutePosition.X) / sliderFrame.AbsoluteSize.X, 0, 1)
		current = 1 + (500 - 1) * alpha
		updateSlider()
		if Actions.CFrameFlyValue then Actions.CFrameFlyValue(current) end
	end
	
	toggleBtn.MouseButton1Click:Connect(function() setToggle(not active) end)
	box.InputBegan:Connect(function(i) 
		if i.UserInputType == Enum.UserInputType.MouseButton1 then 
			setToggle(not active) 
		end 
	end)
	
	sliderFrame.InputBegan:Connect(function(i)
		if i.UserInputType == Enum.UserInputType.MouseButton1 then
			CoreX.activeSlider = sliderFrame
			CoreX.activeSliderCallback = setSliderFromX
			setSliderFromX(i.Position.X)
		end
	end)
	
	row.MouseEnter:Connect(function() row.BackgroundColor3 = Colors.SurfaceLighter end)
	row.MouseLeave:Connect(function() row.BackgroundColor3 = Colors.SurfaceLight end)
	
	toggleSetters["CFrameFly"] = function(on) setToggle(on) end
	updateSlider()
	setToggle(false)
end

-- Register with GUI system
if CoreX.RegisterPageBuilder then
	CoreX.RegisterPageBuilder("Movement", function(page, createHeader, createToggle, createSmallToggle, createSliderOnly, createToggleSlider, createToggleWithHotkey)
		-- Disable scrolling for Movement page
		page.ScrollingEnabled = false
		page.ScrollBarThickness = 0
		page.CanvasSize = UDim2.new(0, 0, 0, 0)
		
		-- BUILD MOVEMENT PAGE
		createHeader(page, "Movement", Colors.Movement)
		createToggleSlider(page, "Speed", "Speed", "SpeedValue", 16, 500, 50, Colors.Movement)
		createToggleSlider(page, "Jump", "Jump", "JumpValue", 1, 500, 50, Colors.Movement)
		createToggle(page, "InfJump", "Infinite Jump", Colors.Movement)
		
		createHeader(page, "CFrame Movement", Colors.Movement)
		createCFrameFlyRowWithKeybind(page, Colors.NeonRed)
		
		createHeader(page, "Camera", Colors.Utility)
		createToggleWithHotkey(page, "CameraDesync", "Camera Desync", Colors.Utility)
		createToggleSlider(page, "FOV", "FOV", "FOVValue", 30, 120, 70, Colors.Utility)
		
		createHeader(page, "Character", Colors.Combat)
		createToggleWithHotkey(page, "Noclip", "Noclip", Colors.Movement)
	end)
end

print("âœ“ Movement Module Loaded")

return true
