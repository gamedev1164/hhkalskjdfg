--==============================================================================
--                         COREX GUI V1.7 - TROLLING MODULE
--==============================================================================

local CoreX = _G.CoreXShared
if not CoreX then error("CoreX core not loaded!") return end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer

local Colors = CoreX.Colors
local Actions = CoreX.Actions
local toggleStates = CoreX.toggleStates
local toggleSetters = CoreX.toggleSetters

-- Helper functions
local function getChar() return player.Character end
local function getHRP() local c = getChar() return c and c:FindFirstChild("HumanoidRootPart") end
local function hasForceField(p) return p.Character and p.Character:FindFirstChildOfClass("ForceField") end

local WASTELANDER_TEAMS = {["subject"] = true, ["sewer dweller"] = true, ["wastelander"] = true}

local function isWastelander(plr)
	if not plr or not plr.Team then return false end
	local t = plr.Team.Name:lower()
	return WASTELANDER_TEAMS[t] or t:find("subject") or t:find("sewer") or t:find("wastelander")
end

local function isAegis(plr)
	if not plr or not plr.Team then return false end
	return not isWastelander(plr)
end

-- TP All State
Actions._tpAllEnabled = false
Actions._tpAllConn = nil
Actions._tpAllDistance = 5
Actions._tpAllOriginalPositions = {}

local function startTpAll()
	Actions._tpAllOriginalPositions = {}
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= player and plr.Character then
			local tHrp = plr.Character:FindFirstChild("HumanoidRootPart")
			if tHrp then 
				Actions._tpAllOriginalPositions[plr.Name] = tHrp.CFrame 
			end
		end
	end
	if Actions._tpAllConn then Actions._tpAllConn:Disconnect() end
	Actions._tpAllConn = RunService.Heartbeat:Connect(function()
		if not CoreX.scriptEnabled or not Actions._tpAllEnabled then return end
		local myHrp = getHRP()
		if not myHrp then return end
		local look = myHrp.CFrame.LookVector
		local targetPos = myHrp.Position + look * Actions._tpAllDistance
		for _, plr in ipairs(Players:GetPlayers()) do
			if plr ~= player and plr.Character and not hasForceField(plr) then
				local tHrp = plr.Character:FindFirstChild("HumanoidRootPart")
				if tHrp then 
					tHrp.CFrame = CFrame.new(targetPos) 
				end
			end
		end
	end)
	table.insert(CoreX.Conns, Actions._tpAllConn)
end

local function stopTpAll()
	if Actions._tpAllConn then 
		Actions._tpAllConn:Disconnect() 
		Actions._tpAllConn = nil 
	end
	task.spawn(function()
		for playerName, originalCFrame in pairs(Actions._tpAllOriginalPositions) do
			local plr = Players:FindFirstChild(playerName)
			if plr and plr.Character then
				local tHrp = plr.Character:FindFirstChild("HumanoidRootPart")
				if tHrp then 
					pcall(function() 
						tHrp.CFrame = originalCFrame 
					end) 
				end
			end
		end
		Actions._tpAllOriginalPositions = {}
	end)
end

-- Fling State
Actions._flingEnabled = false
Actions._flingConn = nil
Actions._flingMode = "All"
Actions._flungPlayers = {}
Actions._currentFlingTarget = nil
Actions._flingTimePerTarget = 1.2

local function getNextFlingTarget()
	local validTargets = {}
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= player and plr.Character and not hasForceField(plr) then
			local tHrp = plr.Character:FindFirstChild("HumanoidRootPart")
			local tHum = plr.Character:FindFirstChildOfClass("Humanoid")
			if tHrp and tHum and tHum.Health > 0 then
				if not Actions._flungPlayers[plr.Name] then
					local shouldInclude = false
					if Actions._flingMode == "All" then 
						shouldInclude = true
					elseif Actions._flingMode == "Wastelander" then 
						shouldInclude = isWastelander(plr)
					elseif Actions._flingMode == "Aegis" then 
						shouldInclude = isAegis(plr) 
					end
					if shouldInclude then 
						table.insert(validTargets, plr) 
					end
				end
			end
		end
	end
	return #validTargets > 0 and validTargets[1] or nil
end

local function startFling()
	if Actions._flingConn then Actions._flingConn:Disconnect() end
	local hrp = getHRP()
	local char = getChar()
	if not hrp or not char then return end
	Actions._flungPlayers = {}
	Actions._currentFlingTarget = nil
	local targetStartTime = tick()
	for _, part in pairs(char:GetDescendants()) do
		if part:IsA("BasePart") then
			part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
			part.CanCollide = false
		end
	end
	Actions._flingConn = RunService.Heartbeat:Connect(function()
		if not CoreX.scriptEnabled or not Actions._flingEnabled then return end
		local myHrp = getHRP()
		if not myHrp then return end
		if not Actions._currentFlingTarget or not Actions._currentFlingTarget.Character or 
		   not Actions._currentFlingTarget.Character:FindFirstChild("HumanoidRootPart") or 
		   tick() - targetStartTime >= Actions._flingTimePerTarget then
			if Actions._currentFlingTarget then 
				Actions._flungPlayers[Actions._currentFlingTarget.Name] = true 
			end
			Actions._currentFlingTarget = getNextFlingTarget()
			targetStartTime = tick()
			if not Actions._currentFlingTarget then
				Actions._flungPlayers = {}
				Actions._currentFlingTarget = getNextFlingTarget()
				if not Actions._currentFlingTarget then
					local t = tick() * 50
					myHrp.CFrame = myHrp.CFrame * CFrame.Angles(t, t, t)
					myHrp.AssemblyAngularVelocity = Vector3.new(500, 500, 500)
					return
				end
			end
		end
		local target = Actions._currentFlingTarget
		if not target or not target.Character then return end
		local targetHrp = target.Character:FindFirstChild("HumanoidRootPart")
		if not targetHrp then return end
		local targetPos = targetHrp.Position
		local t = tick() * 300
		myHrp.CFrame = CFrame.new(targetPos + Vector3.new(math.sin(t) * 0.2, math.sin(t * 1.3) * 0.2, math.cos(t) * 0.2)) * CFrame.Angles(t * 3, t * 4, t * 2)
		myHrp.AssemblyLinearVelocity = Vector3.new(math.sin(t * 5) * 1500, math.cos(t * 6) * 1500, math.sin(t * 5.5) * 1500)
		myHrp.AssemblyAngularVelocity = Vector3.new(math.random(-500, 500), math.random(-500, 500), math.random(-500, 500))
		pcall(function() 
			targetHrp.AssemblyLinearVelocity = targetHrp.AssemblyLinearVelocity + Vector3.new(math.random(-200, 200), math.random(100, 300), math.random(-200, 200)) 
		end)
	end)
	table.insert(CoreX.Conns, Actions._flingConn)
end

local function stopFling()
	if Actions._flingConn then 
		Actions._flingConn:Disconnect() 
		Actions._flingConn = nil 
	end
	local hrp = getHRP()
	local char = getChar()
	if hrp then 
		hrp.AssemblyLinearVelocity = Vector3.zero 
		hrp.AssemblyAngularVelocity = Vector3.zero 
	end
	if char then
		for _, part in pairs(char:GetDescendants()) do
			if part:IsA("BasePart") then 
				part.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0.3, 0.5, 1, 1) 
			end
		end
	end
	Actions._flungPlayers = {}
	Actions._currentFlingTarget = nil
end

-- Touch Fling State
Actions._touchFlingEnabled = false
Actions._touchFlingThread = nil
Actions._touchFlingActive = false

local function startTouchFling()
	if Actions._touchFlingThread then 
		pcall(function() 
			task.cancel(Actions._touchFlingThread) 
		end) 
	end
	Actions._touchFlingActive = true
	local movel = 0.1
	Actions._touchFlingThread = task.spawn(function()
		while Actions._touchFlingActive and Actions._touchFlingEnabled and CoreX.scriptEnabled do
			local char = getChar()
			local hrp = getHRP()
			if char and hrp and Actions._touchFlingActive and Actions._touchFlingEnabled then
				local vel = hrp.Velocity
				hrp.Velocity = vel * 10000 + Vector3.new(0, 10000, 0)
				RunService.RenderStepped:Wait()
				if not Actions._touchFlingActive or not Actions._touchFlingEnabled then
					pcall(function() 
						hrp.Velocity = Vector3.zero 
						hrp.AssemblyLinearVelocity = Vector3.zero 
						hrp.AssemblyAngularVelocity = Vector3.zero 
					end)
					break
				end
				if char and char.Parent and hrp and hrp.Parent then 
					hrp.Velocity = vel 
				end
				RunService.Stepped:Wait()
				if not Actions._touchFlingActive or not Actions._touchFlingEnabled then
					pcall(function() 
						hrp.Velocity = Vector3.zero 
						hrp.AssemblyLinearVelocity = Vector3.zero 
					end)
					break
				end
				if char and char.Parent and hrp and hrp.Parent then 
					hrp.Velocity = vel + Vector3.new(0, movel, 0) 
					movel = movel * -1 
				end
			end
			RunService.Heartbeat:Wait()
		end
	end)
end

local function stopTouchFling()
	Actions._touchFlingActive = false
	Actions._touchFlingEnabled = false
	task.wait(0.05)
	if Actions._touchFlingThread then 
		pcall(function() 
			task.cancel(Actions._touchFlingThread) 
		end) 
		Actions._touchFlingThread = nil 
	end
	task.wait(0.1)
	for i = 1, 30 do
		task.wait()
		local hrp = getHRP()
		if hrp then 
			pcall(function() 
				hrp.Velocity = Vector3.zero 
				hrp.AssemblyLinearVelocity = Vector3.zero 
				hrp.AssemblyAngularVelocity = Vector3.zero 
			end) 
		end
	end
end

-- Chat Bypass State
Actions._chatBypassLoaded = false

local function loadChatBypass()
	if Actions._chatBypassLoaded then return end
	pcall(function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/2EzMyBoi/Roblox-Scripts/refs/heads/main/UselessBypasser"))()
		Actions._chatBypassLoaded = true
	end)
end

--==============================================================================
--                         AUTO DOOR SYSTEM
--==============================================================================

-- Auto Door State
Actions._autoDoorEnabled = false
Actions._autoDoorRsConn = nil
Actions._autoDoorScanThread = nil
Actions._autoDoorToggleThread = nil
Actions._autoDoorModels = {}
Actions._autoDoorHitboxes = {}
Actions._autoDoorClickDetectors = {}
Actions._autoDoorOriginalState = {}

local TARGET_DOOR_NAMES = {["DoorTall"] = true, ["DoorWide"] = true}
local DOOR_AMPLITUDE = 1.25
local DOOR_SPEED = 3.0
local DOOR_EXTRA_FORWARD = 2.0
local DOOR_TOGGLE_INTERVAL = 0.5
local DOOR_RESCAN_INTERVAL = 1.0

local function isHitboxPart(inst)
	if not inst:IsA("BasePart") then return false end
	local n = (inst.Name or ""):lower()
	return (n == "hitbox") or (n:find("hitbox") ~= nil)
end

local function getRightArmPart(char)
	return char:FindFirstChild("RightHand")
		or char:FindFirstChild("RightLowerArm")
		or char:FindFirstChild("RightUpperArm")
		or char:FindFirstChild("Right Arm")
end

local function clearDoorCaches()
	Actions._autoDoorModels = {}
	Actions._autoDoorHitboxes = {}
	Actions._autoDoorClickDetectors = {}
end

local function scanDoors()
	clearDoorCaches()
	
	for _, inst in ipairs(Workspace:GetDescendants()) do
		if inst:IsA("Model") and TARGET_DOOR_NAMES[inst.Name] then
			Actions._autoDoorModels[inst] = true
		end
	end
	
	for mdl in pairs(Actions._autoDoorModels) do
		for _, d in ipairs(mdl:GetDescendants()) do
			if isHitboxPart(d) then
				table.insert(Actions._autoDoorHitboxes, d)
			elseif d:IsA("ClickDetector") then
				table.insert(Actions._autoDoorClickDetectors, d)
			end
		end
	end
end

local function rememberDoorOriginal(part)
	if Actions._autoDoorOriginalState[part] then return end
	Actions._autoDoorOriginalState[part] = {
		CFrame = part.CFrame,
		Anchored = part.Anchored,
		CanCollide = part.CanCollide,
		Transparency = part.Transparency,
		Size = part.Size,
	}
end

local function restoreDoorHitboxes()
	for part, st in pairs(Actions._autoDoorOriginalState) do
		if part and part.Parent then
			pcall(function()
				part.CFrame = st.CFrame
				part.Anchored = st.Anchored
				part.CanCollide = st.CanCollide
				part.Transparency = st.Transparency
				part.Size = st.Size
			end)
		end
	end
	Actions._autoDoorOriginalState = {}
end

local function computeArmTipCF(arm)
	local halfDepth = (arm.Size.Z * 0.5)
	return arm.CFrame * CFrame.new(0, 0, -(halfDepth + DOOR_EXTRA_FORWARD))
end

local function fireAllDoorClickDetectors()
	if typeof(fireclickdetector) ~= "function" then return false end
	for _, cd in ipairs(Actions._autoDoorClickDetectors) do
		if cd and cd.Parent then
			pcall(function() fireclickdetector(cd) end)
		end
	end
	return true
end

local function startAutoDoor()
	scanDoors()
	
	-- Rescan doors periodically
	Actions._autoDoorScanThread = task.spawn(function()
		while Actions._autoDoorEnabled and CoreX.scriptEnabled do
			task.wait(DOOR_RESCAN_INTERVAL)
			if not Actions._autoDoorEnabled then break end
			scanDoors()
		end
	end)
	
	-- Toggle doors constantly
	Actions._autoDoorToggleThread = task.spawn(function()
		while Actions._autoDoorEnabled and CoreX.scriptEnabled do
			task.wait(DOOR_TOGGLE_INTERVAL)
			if not Actions._autoDoorEnabled then break end
			fireAllDoorClickDetectors()
		end
	end)
	
	-- Move hitboxes to arm tip with oscillation
	local t0 = os.clock()
	Actions._autoDoorRsConn = RunService.RenderStepped:Connect(function()
		if not Actions._autoDoorEnabled or not CoreX.scriptEnabled then return end
		local char = getChar()
		if not char then return end
		
		local arm = getRightArmPart(char)
		if not arm then return end
		
		local baseCF = computeArmTipCF(arm)
		local tt = (os.clock() - t0)
		local z = math.sin(tt * DOOR_SPEED) * DOOR_AMPLITUDE
		local moveCF = baseCF * CFrame.new(0, 0, -z)
		
		for _, hb in ipairs(Actions._autoDoorHitboxes) do
			if hb and hb.Parent then
				rememberDoorOriginal(hb)
				hb.Anchored = true
				hb.CanCollide = false
				hb.Transparency = 0.7  -- 70% transparent
				hb.CFrame = moveCF
			end
		end
	end)
	table.insert(CoreX.Conns, Actions._autoDoorRsConn)
end

local function stopAutoDoor()
	if Actions._autoDoorRsConn then 
		Actions._autoDoorRsConn:Disconnect() 
		Actions._autoDoorRsConn = nil 
	end
	if Actions._autoDoorScanThread then 
		task.cancel(Actions._autoDoorScanThread) 
		Actions._autoDoorScanThread = nil 
	end
	if Actions._autoDoorToggleThread then 
		task.cancel(Actions._autoDoorToggleThread) 
		Actions._autoDoorToggleThread = nil 
	end
	restoreDoorHitboxes()
	clearDoorCaches()
end

--==============================================================================
--                         AUTO BOOTH QUEUE SYSTEM
--==============================================================================

-- Auto Booth State
Actions._autoBoothEnabled = false
Actions._autoBoothThread = nil

local BOOTH_TOUCH_INTERVAL = 1.0
local BOOTH_ROOT = nil
local BOOTH_TARGET_NAME = "Processing_BoothSystem"

local function getBoothRoot()
	if not BOOTH_ROOT then
		BOOTH_ROOT = Workspace:FindFirstChild("Booths")
	end
	return BOOTH_ROOT
end

local function getAllProcessingBoothSystems()
	local root = getBoothRoot()
	if not root then return {} end
	
	local systems = {}
	for _, obj in ipairs(root:GetDescendants()) do
		if obj.Name == BOOTH_TARGET_NAME then
			table.insert(systems, obj)
		end
	end
	return systems
end

local function getTouchPartsUnderSystems()
	local parts = {}
	local seen = {}
	
	for _, sys in ipairs(getAllProcessingBoothSystems()) do
		for _, d in ipairs(sys:GetDescendants()) do
			-- TouchInterest shows as TouchTransmitter in code
			if d:IsA("TouchTransmitter") then
				local part = d.Parent
				if part and part:IsA("BasePart") and not seen[part] then
					seen[part] = true
					table.insert(parts, part)
				end
			end
		end
	end
	
	return parts
end

local function touchBoothParts()
	if typeof(firetouchinterest) ~= "function" then return false end
	
	local hrp = getHRP()
	if not hrp then return false end
	
	local parts = getTouchPartsUnderSystems()
	for _, part in ipairs(parts) do
		if part and part.Parent then
			pcall(function()
				firetouchinterest(hrp, part, 0)
				firetouchinterest(hrp, part, 1)
			end)
		end
	end
	return true
end

local function startAutoBooth()
	Actions._autoBoothThread = task.spawn(function()
		while Actions._autoBoothEnabled and CoreX.scriptEnabled do
			touchBoothParts()
			task.wait(BOOTH_TOUCH_INTERVAL)
		end
	end)
end

local function stopAutoBooth()
	if Actions._autoBoothThread then
		task.cancel(Actions._autoBoothThread)
		Actions._autoBoothThread = nil
	end
end

-- Action Handlers
function Actions.TpAllFront(on)
	Actions._tpAllEnabled = on
	if on then 
		startTpAll() 
	else 
		stopTpAll() 
	end
end

function Actions.TpAllDistance(v) 
	Actions._tpAllDistance = math.clamp(tonumber(v) or 5, 1, 50) 
end

function Actions.FlingAll(on)
	if on then
		Actions._flingMode = "All"
		Actions._flingEnabled = true
		if toggleSetters["FlingWastelander"] then 
			toggleSetters["FlingWastelander"](false) 
		end
		if toggleSetters["FlingAegis"] then 
			toggleSetters["FlingAegis"](false) 
		end
		startFling()
	else
		if Actions._flingMode == "All" then 
			Actions._flingEnabled = false 
			stopFling() 
		end
	end
end

function Actions.FlingWastelander(on)
	if on then
		Actions._flingMode = "Wastelander"
		Actions._flingEnabled = true
		if toggleSetters["FlingAll"] then 
			toggleSetters["FlingAll"](false) 
		end
		if toggleSetters["FlingAegis"] then 
			toggleSetters["FlingAegis"](false) 
		end
		startFling()
	else
		if Actions._flingMode == "Wastelander" then 
			Actions._flingEnabled = false 
			stopFling() 
		end
	end
end

function Actions.FlingAegis(on)
	if on then
		Actions._flingMode = "Aegis"
		Actions._flingEnabled = true
		if toggleSetters["FlingAll"] then 
			toggleSetters["FlingAll"](false) 
		end
		if toggleSetters["FlingWastelander"] then 
			toggleSetters["FlingWastelander"](false) 
		end
		startFling()
	else
		if Actions._flingMode == "Aegis" then 
			Actions._flingEnabled = false 
			stopFling() 
		end
	end
end

function Actions.TouchFling(on)
	if on then 
		Actions._touchFlingEnabled = true 
		Actions._touchFlingActive = true 
		startTouchFling()
	else 
		stopTouchFling() 
	end
end

function Actions.LoadChatBypass(on)
	if not on then return end
	loadChatBypass()
	task.delay(0.1, function() 
		if toggleSetters["LoadChatBypass"] then 
			toggleSetters["LoadChatBypass"](false) 
		end 
	end)
end

function Actions.AutoDoor(on)
	Actions._autoDoorEnabled = on
	if on then
		startAutoDoor()
	else
		stopAutoDoor()
	end
end

function Actions.AutoBooth(on)
	Actions._autoBoothEnabled = on
	if on then
		startAutoBooth()
	else
		stopAutoBooth()
	end
end

-- Register with GUI system
if CoreX.RegisterPageBuilder then
	CoreX.RegisterPageBuilder("Trolling", function(page, createHeader, createToggle, createSmallToggle, createSliderOnly, createToggleSlider)
		-- BUILD TROLLING PAGE
		createHeader(page, "TP All", Colors.Trolling)
		createToggleSlider(page, "TpAllFront", "TP All", "TpAllDistance", 1, 50, 5, Colors.Trolling)
		
		createHeader(page, "Ultra Fling", Colors.Trolling)
		createToggle(page, "FlingAll", "⚡ Fling All", Colors.Trolling)
		createToggle(page, "FlingWastelander", "⚡ Fling Wastelanders", Colors.Wastelander)
		createToggle(page, "FlingAegis", "⚡ Fling Aegis", Colors.Aegis)
		
		createHeader(page, "Touch Fling", Colors.NeonOrange)
		createToggle(page, "TouchFling", "Touch Fling", Colors.NeonOrange)
		
		createHeader(page, "Auto Systems", Colors.NeonCyan)
		createToggle(page, "AutoDoor", "Auto Open/Close Doors", Colors.NeonCyan)
		createToggle(page, "AutoBooth", "Auto Processing Booth Queue", Colors.NeonCyan)
		
		createHeader(page, "Chat", Colors.Accent)
		createToggle(page, "LoadChatBypass", "Load Chat Bypass", Colors.Accent)
	end)
end

print("✓ Trolling Module Loaded")

return true
