-- MODULE 2: Resource Mining System (STANDALONE)
-- This module handles resource collection from Fedorlite after pickaxe is obtained

local Module2 = {}

-- Services
local Players = game:GetService("Players")

-- Configuration
Module2.Config = {
    FEDORLITE_NAME = "Fedorlite",
    RESOURCE_NAME = "Resource",
    HOLD_DURATION = 0.5,
    RETRY_DELAY = 0.1
}

-- Initialize player references
function Module2:Init()
    self.player = Players.LocalPlayer
    self.character = self.player.Character or self.player.CharacterAdded:Wait()
    self.humanoidRootPart = self.character:WaitForChild("HumanoidRootPart")
    
    -- Handle character respawn
    self.player.CharacterAdded:Connect(function(newCharacter)
        self.character = newCharacter
        self.humanoidRootPart = newCharacter:WaitForChild("HumanoidRootPart")
    end)
    
    print("[Module 2] Initialized - Resource Mining System")
end

-- Check if player has both required items
function Module2:HasRequiredItems()
    local backpack = self.player:WaitForChild("Backpack")
    
    local hasRespirator = backpack:FindFirstChild("Civilian Grade Respirator")
    local hasFilter = backpack:FindFirstChild("Filter Replacement")
    
    if hasRespirator and hasFilter then
        print("[Module 2] ✓ Both items detected in backpack!")
        return true
    end
    
    return false
end

-- Teleport to sell location and execute sell scripts
function Module2:SellAndBuy()
    print("[Module 2] Teleporting to sell location...")
    
    -- Teleport to sell location: 312 23 -572
    self.humanoidRootPart.CFrame = CFrame.new(312, 23, -572)
    wait(2)
    
    print("[Module 2] Teleporting to buy location...")
    
    -- Teleport to buy location: -240 13 -839
    self.humanoidRootPart.CFrame = CFrame.new(-240, 13, -839)
    wait(0.5)
    
    print("[Module 2] Purchasing Civilian Grade Respirator...")
    
    -- Buy Civilian Grade Respirator
    local args1 = {
        "Civilian Grade Respirator",
        "BARTON_EC"
    }
    game:GetService("ReplicatedStorage"):WaitForChild("MERCHANT"):WaitForChild("MClientCommunication"):FireServer(unpack(args1))
    
    wait(0.3)
    
    print("[Module 2] Purchasing Filter Replacement...")
    
    -- Buy Filter Replacement
    local args2 = {
        "Filter Replacement",
        "BARTON_EC"
    }
    game:GetService("ReplicatedStorage"):WaitForChild("MERCHANT"):WaitForChild("MClientCommunication"):FireServer(unpack(args2))
    
    wait(0.5)
    
    print("[Module 2] Purchase commands sent!")
end
    local backpack = self.player:WaitForChild("Backpack")
    local characterTools = self.character:GetChildren()
    
    -- Check backpack
    if backpack:FindFirstChild("Pickaxe") then
        return true
    end
    
    -- Check equipped tools
    for _, item in pairs(characterTools) do
        if item:IsA("Tool") and item.Name == "Pickaxe" then
            return true
        end
    end
    
    return false
end

-- Equip the pickaxe
function Module2:EquipPickaxe()
    local backpack = self.player:WaitForChild("Backpack")
    local pickaxe = backpack:FindFirstChild("Pickaxe")
    
    if pickaxe then
        self.character.Humanoid:EquipTool(pickaxe)
        print("[Module 2] Pickaxe equipped!")
        return true
    else
        -- Check if already equipped
        for _, item in pairs(self.character:GetChildren()) do
            if item:IsA("Tool") and item.Name == "Pickaxe" then
                print("[Module 2] Pickaxe already equipped!")
                return true
            end
        end
        print("[Module 2] Pickaxe not found in backpack!")
        return false
    end
end

-- Find all Fedorlite models in workspace
function Module2:FindFedorliteModels()
    local fedorlites = {}
    local workspace = game:GetService("Workspace")
    
    print("[Module 2] Searching for Fedorlite models...")
    
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and obj.Name == self.Config.FEDORLITE_NAME then
            table.insert(fedorlites, obj)
            print("[Module 2] Found Fedorlite: " .. obj:GetFullName())
        end
    end
    
    if #fedorlites == 0 then
        print("[Module 2] WARNING: No Fedorlite models found!")
        print("[Module 2] Searching for any object named 'Fedorlite'...")
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj.Name == self.Config.FEDORLITE_NAME then
                print("[Module 2] Found non-model Fedorlite: " .. obj:GetFullName() .. " (Type: " .. obj.ClassName .. ")")
            end
        end
    else
        print("[Module 2] Found " .. #fedorlites .. " Fedorlite models")
    end
    
    return fedorlites
end

-- Find Resource objects within a Fedorlite model
function Module2:FindResourcesInFedorlite(fedorliteModel)
    local resources = {}
    
    print("[Module 2] Searching for Resources in: " .. fedorliteModel:GetFullName())
    
    for _, obj in pairs(fedorliteModel:GetDescendants()) do
        if obj.Name == self.Config.RESOURCE_NAME then
            table.insert(resources, obj)
            print("[Module 2] Found Resource: " .. obj:GetFullName() .. " (Type: " .. obj.ClassName .. ")")
        end
    end
    
    print("[Module 2] Total resources found in this Fedorlite: " .. #resources)
    
    return resources
end

-- Mine a single resource
function Module2:MineResource(resourceObject)
    print("[Module 2] === Attempting to mine: " .. resourceObject:GetFullName() .. " ===")
    
    -- Check if resource is already mined (transparency = 1)
    if resourceObject:IsA("BasePart") and resourceObject.Transparency >= 1 then
        print("[Module 2] Resource already mined (transparent)")
        return true
    end
    
    -- Find the actual part if resourceObject is a model
    local resourcePart = resourceObject:IsA("BasePart") and resourceObject or resourceObject:FindFirstChildWhichIsA("BasePart", true)
    
    if not resourcePart then
        print("[Module 2] No BasePart found in resource")
        return false
    end
    
    -- Check transparency again on the part
    if resourcePart.Transparency >= 1 then
        print("[Module 2] Resource already mined (transparent)")
        return true
    end
    
    -- Find ProximityAttachment first, then ProximityPrompt inside it
    local proximityPrompt = nil
    local proximityAttachment = resourceObject:FindFirstChild("ProximityAttachment", true)
    
    if proximityAttachment then
        print("[Module 2] Found ProximityAttachment at: " .. proximityAttachment:GetFullName())
        proximityPrompt = proximityAttachment:FindFirstChildOfClass("ProximityPrompt")
        
        if proximityPrompt then
            print("[Module 2] Found ProximityPrompt at: " .. proximityPrompt:GetFullName())
        end
    end
    
    -- Fallback: search for ProximityPrompt anywhere in resource
    if not proximityPrompt then
        print("[Module 2] Searching for ProximityPrompt in entire resource tree...")
        proximityPrompt = resourceObject:FindFirstChildOfClass("ProximityPrompt", true)
    end
    
    if not proximityPrompt then
        print("[Module 2] ERROR: No ProximityPrompt found in " .. resourceObject.Name)
        print("[Module 2] Skipping this resource...")
        return false
    end
    
    print("[Module 2] ✓ ProximityPrompt found and ready!")
    
    -- Teleport 2 studs above resource
    local resourcePosition = resourcePart.Position
    local targetPosition = resourcePosition + Vector3.new(0, 2, 0)
    self.humanoidRootPart.CFrame = CFrame.new(targetPosition)
    
    print("[Module 2] Teleported to position: " .. tostring(targetPosition))
    
    -- Set up transparency monitoring
    local mined = false
    local connection
    
    connection = resourcePart:GetPropertyChangedSignal("Transparency"):Connect(function()
        if resourcePart.Transparency >= 1 then
            print("[Module 2] Transparency changed to 1 - Resource mined!")
            mined = true
            connection:Disconnect()
        end
    end)
    
    -- Position update loop to keep player in place
    local keepInPlace = true
    task.spawn(function()
        while keepInPlace do
            local currentResourcePos = resourcePart.Position
            local currentTargetPos = currentResourcePos + Vector3.new(0, 2, 0)
            self.humanoidRootPart.CFrame = CFrame.new(currentTargetPos)
            wait(0.001) -- Update every 0.001 seconds
        end
    end)
    
    -- Keep attempting to mine
    local attempts = 0
    while not mined do
        attempts = attempts + 1
        
        -- Fire proximity prompt
        fireproximityprompt(proximityPrompt, self.Config.HOLD_DURATION)
        print("[Module 2] Mining attempt #" .. attempts .. " - Fired ProximityPrompt")
        
        -- Wait and check
        wait(self.Config.HOLD_DURATION + 0.1)
        
        if resourcePart.Transparency >= 1 then
            mined = true
            break
        end
        
        -- Check if prompt still exists
        if not proximityPrompt or not proximityPrompt.Parent then
            print("[Module 2] ProximityPrompt disappeared - resource may be mined")
            mined = true
            break
        end
        
        -- Retry delay
        wait(self.Config.RETRY_DELAY)
        
        if attempts > 20 then
            print("[Module 2] Too many attempts, moving to next resource...")
            break
        end
    end
    
    -- Stop position updates
    keepInPlace = false
    connection:Disconnect()
    
    if mined then
        print("[Module 2] ✓ Successfully mined resource!")
        return true
    else
        print("[Module 2] ✗ Failed to mine resource after " .. attempts .. " attempts")
        return false
    end
end

-- Mine all resources in all Fedorlite models
function Module2:MineAllResources()
    print("[Module 2] ===== Starting mining cycle =====")
    
    local fedorlites = self:FindFedorliteModels()
    
    if #fedorlites == 0 then
        print("[Module 2] No Fedorlite models found! Skipping this cycle.")
        return false
    end
    
    local totalMined = 0
    
    for fedIndex, fedorlite in ipairs(fedorlites) do
        print("[Module 2] Processing Fedorlite " .. fedIndex .. "/" .. #fedorlites)
        
        local resources = self:FindResourcesInFedorlite(fedorlite)
        
        if #resources == 0 then
            print("[Module 2] No resources in this Fedorlite, skipping...")
        else
            for resIndex, resource in ipairs(resources) do
                print("[Module 2] Mining resource " .. resIndex .. "/" .. #resources)
                
                -- Update character reference
                self.character = self.player.Character or self.player.CharacterAdded:Wait()
                self.humanoidRootPart = self.character:WaitForChild("HumanoidRootPart")
                
                local success = self:MineResource(resource)
                if success then
                    totalMined = totalMined + 1
                end
                
                task.wait()
            end
        end
    end
    
    print("[Module 2] Mining cycle complete! Mined " .. totalMined .. " resources")
    return totalMined > 0
end

-- Mine exactly 1 resource then return
function Module2:MineOneResource()
    print("[Module 2] ===== Mining 1 resource before sell =====")
    
    local fedorlites = self:FindFedorliteModels()
    
    if #fedorlites == 0 then
        print("[Module 2] No Fedorlite models found!")
        return false
    end
    
    for _, fedorlite in ipairs(fedorlites) do
        local resources = self:FindResourcesInFedorlite(fedorlite)
        
        if #resources > 0 then
            -- Update character reference
            self.character = self.player.Character or self.player.CharacterAdded:Wait()
            self.humanoidRootPart = self.character:WaitForChild("HumanoidRootPart")
            
            -- Mine the first resource found
            local success = self:MineResource(resources[1])
            if success then
                print("[Module 2] ✓ Successfully mined 1 resource!")
                return true
            end
        end
    end
    
    print("[Module 2] Could not mine any resource")
    return false
end

-- Main execution loop
function Module2:Run()
    print("[Module 2] Starting resource mining...")
    
    -- Wait for pickaxe
    while not self:HasPickaxe() do
        print("[Module 2] Waiting for pickaxe...")
        wait(1)
    end
    
    print("[Module 2] Pickaxe detected! Equipping...")
    
    -- Auto-equip pickaxe
    self:EquipPickaxe()
    wait(0.5)
    
    print("[Module 2] Starting mining and selling operation...")
    
    -- Main loop: Mine and sell until we have both items
    while not self:HasRequiredItems() do
        task.wait()
        
        -- Update character reference
        self.character = self.player.Character or self.player.CharacterAdded:Wait()
        self.humanoidRootPart = self.character:WaitForChild("HumanoidRootPart")
        
        -- Make sure pickaxe is equipped
        self:EquipPickaxe()
        
        -- Mine exactly 1 resource
        print("[Module 2] === Starting new cycle ===")
        self:MineOneResource()
        
        -- Sell and buy items
        self:SellAndBuy()
        
        -- Check if we have both items now
        wait(1)
        if self:HasRequiredItems() then
            print("[Module 2] ========================================")
            print("[Module 2] ✓✓✓ ALL ITEMS ACQUIRED! ✓✓✓")
            print("[Module 2] ========================================")
            break
        end
        
        print("[Module 2] Items not yet acquired, continuing cycle...")
        wait(2)
    end
    
    print("[Module 2] ========================================")
    print("[Module 2] SCRIPT COMPLETE - STOPPING")
    print("[Module 2] ========================================")
end

-- STANDALONE EXECUTION - Runs automatically
print("========================================")
print("MODULE 2: Resource Mining System")
print("========================================")

Module2:Init()
Module2:Run()

print("========================================")
print("MODULE 2: RUNNING CONTINUOUSLY")
print("========================================")
