--==============================================================================
--                    WASTELANDER HUB - WASTELANDER SPECTATE MODULE
--==============================================================================

local WastelanderHub = _G.WastelanderHub
if not WastelanderHub or not WastelanderHub.WastelanderSpectate then 
    warn("Wastelander Hub not loaded!") 
    return 
end

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local page = WastelanderHub.WastelanderSpectate
local Library = WastelanderHub.Library

-- Wastelander Team Names
local AEGIS_TEAMS = {
    "WASTELANDER Corporation",
    "Conference",
    "Experiment1",
    "Experiment2",
    "Insurrectionist",
    "Interrogation",
    "Interview1",
    "Interview2",
    "Lesson1",
    "Lesson2",
    "Patrol1",
    "Patrol2",
    "Patrol3",
    "Patrol4",
    "Rally",
    "Sewer Dweller",
    "Subject",
    "The Chairman",
    "Training"
}

-- Rank System (from provided script)
local RANK_ORDER = {
    "Chairman",
    "Table Of Military Leadership",
    "Unit Commander",
    "Unit Captain",
    "Veteran Officer",
    "Warrant Officer",
    "Officer",
    "Administered Specialist",
    "Administered Field Agent",
    "Specialist",
}

local RANKS = {
    ["Administered Field Agent"] = {
        3309970495, 226117655, 689247279, 1975838348, 105892068, 463669642, 861989591
    },
    ["Specialist"] = {37883732, 509426887, 561064343, 1385018628},
    ["Administered Specialist"] = {937564141, 7335374299, 2761696222, 192254622, 139320432},
    ["Officer"] = {3469222247, 755966848, 728586602, 334713155, 817589023},
    ["Warrant Officer"] = {2522740248, 3276554424, 176149128, 2213826264, 189393},
    ["Veteran Officer"] = {1677921525, 62954014, 1818230195, 1695017283, 727677637},
    ["Unit Captain"] = {1938907604, 1509777239, 409397743, 293671581, 100016418},
    ["Unit Commander"] = {82964247, 355588359, 923213464},
    ["Table Of Military Leadership"] = {1419426348, 631228062, 23030407, 100474014, 671292893, 923214624, 112026803},
    ["Chairman"] = {17319802},
}

local RANK_ABBREV = {
    ["Administered Field Agent"] = "AFA",
    ["Specialist"] = "SPC",
    ["Administered Specialist"] = "ASP",
    ["Officer"] = "OFC",
    ["Warrant Officer"] = "WO",
    ["Veteran Officer"] = "VO",
    ["Unit Captain"] = "UCPT",
    ["Unit Commander"] = "UCMD",
    ["Table Of Military Leadership"] = "TML",
    ["Chairman"] = "CHAIR",
}

local RANK_COLORS = {
    Color3.fromRGB(255, 50, 50),     -- Chairman
    Color3.fromRGB(255, 85, 0),      -- TML
    Color3.fromRGB(255, 140, 0),     -- Unit Commander
    Color3.fromRGB(255, 200, 0),     -- Unit Captain
    Color3.fromRGB(255, 255, 0),     -- Veteran Officer
    Color3.fromRGB(150, 255, 50),    -- Warrant Officer
    Color3.fromRGB(50, 255, 120),    -- Officer
    Color3.fromRGB(50, 200, 255),    -- Administered Specialist
    Color3.fromRGB(80, 140, 255),    -- Administered Field Agent
    Color3.fromRGB(120, 120, 255),   -- Specialist
}

-- Create userId to rank lookup
local userIdToRank = {}
local rankToIndex = {}

for rank, userIds in pairs(RANKS) do
    for _, userId in ipairs(userIds) do
        userIdToRank[userId] = rank
    end
end

for index, rank in ipairs(RANK_ORDER) do
    rankToIndex[rank] = index
end

-- Check if player is Wastelander
local function isWastelanderPlayer(plr)
    if not plr or not plr.Team then return false end
    
    for _, teamName in ipairs(WASTELANDER_TEAMS) do
        if plr.Team.Name == teamName then
            return true
        end
    end
-- Check if player is Wastelander (NOT Aegis)
local function isWastelanderPlayer(plr)
    if not plr or not plr.Team then return false end
    
    for _, teamName in ipairs(AEGIS_TEAMS) do
        if plr.Team.Name == teamName then
            return false
        end
    end
    
    return true
end
    if index then
        return RANK_COLORS[index]
    end
    return Color3.fromRGB(150, 150, 150)  -- Gray for no rank
end

-- Get rank abbreviation
local function getRankAbbrev(rank)
    return RANK_ABBREV[rank] or "N/A"
end

-- Get hours played
local function getHoursPlayed(plr)
    -- Path: player → stats → MinutesPlayed (NumberValue in seconds)
    local stats = plr:FindFirstChild("stats")
    if stats then
        local minutesPlayed = stats:FindFirstChild("MinutesPlayed")
        if minutesPlayed and (minutesPlayed:IsA("IntValue") or minutesPlayed:IsA("NumberValue")) then
            -- Value is in seconds, convert to hours
            local hours = minutesPlayed.Value / 3600
            return hours, string.format("%.1fh", hours)
        end
    end
    return 0, "0.0h"
end

-- State
local State = {
    spectating = false,
    targetPlayer = nil,
    originalCamera = nil,
    waitingForRespawn = false,
    healthSyncConnection = nil,
    originalTools = {},
    playerButtons = {},
    gridFrame = nil,
    connections = {},
    spectateConnections = {}
}

-- Store original tools
local function storeOriginalTools()
    State.originalTools = {}
    
    if player.Backpack then
        for _, tool in ipairs(player.Backpack:GetChildren()) do
            if tool:IsA("Tool") then
                table.insert(State.originalTools, tool:Clone())
            end
        end
    end
    
    if player.Character then
        for _, tool in ipairs(player.Character:GetChildren()) do
            if tool:IsA("Tool") then
                table.insert(State.originalTools, tool:Clone())
            end
        end
    end
end

-- Restore original tools
local function restoreOriginalTools()
    -- Clear current backpack
    if player.Backpack then
        for _, tool in ipairs(player.Backpack:GetChildren()) do
            if tool:IsA("Tool") then
                tool:Destroy()
            end
        end
    end
    
    if player.Character then
        for _, tool in ipairs(player.Character:GetChildren()) do
            if tool:IsA("Tool") then
                tool:Destroy()
            end
        end
    end
    
    -- Restore original tools
    for _, tool in ipairs(State.originalTools) do
        local clone = tool:Clone()
        clone.Parent = player.Backpack
    end
    
    State.originalTools = {}
end

-- Clone target's backpack
local function cloneBackpack(targetPlayer)
    if not targetPlayer or not player.Backpack then return end
    
    -- Clear current backpack (except original tools which are already stored)
    if player.Backpack then
        for _, tool in ipairs(player.Backpack:GetChildren()) do
            if tool:IsA("Tool") then
                tool:Destroy()
            end
        end
    end
    
    if player.Character then
        for _, tool in ipairs(player.Character:GetChildren()) do
            if tool:IsA("Tool") then
                tool:Destroy()
            end
        end
    end
    
    -- Clone target's backpack
    if targetPlayer.Backpack then
        for _, tool in ipairs(targetPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") then
                local clone = tool:Clone()
                clone.Parent = player.Backpack
            end
        end
    end
    
    -- Clone tools they're holding
    if targetPlayer.Character then
        for _, tool in ipairs(targetPlayer.Character:GetChildren()) do
            if tool:IsA("Tool") then
                local clone = tool:Clone()
                clone.Parent = player.Backpack
            end
        end
    end
    
    print("✓ Cloned " .. targetPlayer.Name .. "'s backpack")
end

-- Sync health with target
local function startHealthSync(targetPlayer)
    -- Stop previous health sync
    if State.healthSyncConnection then
        State.healthSyncConnection:Disconnect()
        State.healthSyncConnection = nil
    end
    
    -- Start syncing health
    State.healthSyncConnection = game:GetService("RunService").Heartbeat:Connect(function()
        if not State.spectating or State.targetPlayer ~= targetPlayer then
            if State.healthSyncConnection then
                State.healthSyncConnection:Disconnect()
                State.healthSyncConnection = nil
            end
            return
        end
        
        local targetChar = targetPlayer.Character
        local myChar = player.Character
        
        if targetChar and myChar then
            local targetHum = targetChar:FindFirstChildOfClass("Humanoid")
            local myHum = myChar:FindFirstChildOfClass("Humanoid")
            
            if targetHum and myHum then
                -- Sync health
                if myHum.Health ~= targetHum.Health then
                    myHum.Health = targetHum.Health
                end
                
                -- Sync max health
                if myHum.MaxHealth ~= targetHum.MaxHealth then
                    myHum.MaxHealth = targetHum.MaxHealth
                end
            end
        end
    end)
    
    table.insert(State.spectateConnections, State.healthSyncConnection)
end

-- Stop health sync
local function stopHealthSync()
    if State.healthSyncConnection then
        State.healthSyncConnection:Disconnect()
        State.healthSyncConnection = nil
    end
    
    -- Reset health to normal
    if player.Character then
        local hum = player.Character:FindFirstChildOfClass("Humanoid")
        if hum then
            hum.MaxHealth = 100
            hum.Health = 100
        end
    end
end

-- Stop spectating
function stopSpectate()
    if not State.spectating then return end
    
    State.spectating = false
    State.targetPlayer = nil
    State.waitingForRespawn = false
    
    -- Stop health sync
    stopHealthSync()
    
    -- Restore original backpack
    restoreOriginalTools()
    
    -- Disconnect spectate-specific connections
    for _, conn in ipairs(State.spectateConnections) do
        if typeof(conn) == "RBXScriptConnection" then
            conn:Disconnect()
        end
    end
    State.spectateConnections = {}
    
    local camera = Workspace.CurrentCamera
    camera.CameraSubject = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
    camera.CameraType = Enum.CameraType.Custom
    
    print("✓ Stopped spectating")
end

-- Spectate player
local function spectatePlayer(targetPlayer)
    if not targetPlayer then
        warn("Target player is nil")
        return
    end
    
    local camera = Workspace.CurrentCamera
    
    -- Stop previous spectate
    if State.spectating then
        stopSpectate()
    end
    
    -- Store original tools before starting
    storeOriginalTools()
    
    -- Start spectating
    State.spectating = true
    State.targetPlayer = targetPlayer
    State.waitingForRespawn = false
    
    -- Function to attach camera to character
    local function attachCamera(character)
        if not State.spectating or State.targetPlayer ~= targetPlayer then return end
        
        local hum = character:FindFirstChildOfClass("Humanoid")
        if hum then
            camera.CameraSubject = hum
            camera.CameraType = Enum.CameraType.Custom
            State.waitingForRespawn = false
            
            -- Clone backpack
            cloneBackpack(targetPlayer)
            
            -- Start health sync
            startHealthSync(targetPlayer)
            
            print("✓ Now spectating " .. targetPlayer.Name)
        end
    end
    
    -- Attach to current character if exists
    if targetPlayer.Character then
        attachCamera(targetPlayer.Character)
    else
        State.waitingForRespawn = true
        print("⏳ Waiting for " .. targetPlayer.Name .. " to respawn...")
    end
    
    -- Monitor for character respawn (death)
    local charAddedConn = targetPlayer.CharacterAdded:Connect(function(character)
        if not State.spectating or State.targetPlayer ~= targetPlayer then return end
        
        State.waitingForRespawn = true
        print("⏳ " .. targetPlayer.Name .. " died, waiting for respawn...")
        
        -- Wait for character to fully load
        task.wait(0.5)
        
        if State.spectating and State.targetPlayer == targetPlayer then
            attachCamera(character)
        end
    end)
    table.insert(State.spectateConnections, charAddedConn)
    
    -- Monitor if player leaves (cancel spectate)
    local playerLeavingConn
    playerLeavingConn = game:GetService("Players").PlayerRemoving:Connect(function(plr)
        if plr == targetPlayer and State.spectating and State.targetPlayer == targetPlayer then
            print("✓ " .. targetPlayer.Name .. " left the game")
            stopSpectate()
            createPlayerList()  -- Refresh to remove highlight
        end
    end)
    table.insert(State.spectateConnections, playerLeavingConn)
end

-- Create player grid (3 columns)
local function createPlayerList()
    -- Clear existing buttons
    for _, btn in pairs(State.playerButtons) do
        btn:Destroy()
    end
    State.playerButtons = {}
    
    -- Collect all Wastelander players (with or without rank)
    local aegisPlayers = {}
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= player and isWastelanderPlayer(plr) then
            local rank = getPlayerRank(plr)
            local rankIndex = rankToIndex[rank] or 999
            local hoursNum, hoursText = getHoursPlayed(plr)
            
            -- Add all Wastelander players (even without rank)
            table.insert(aegisPlayers, {
                player = plr,
                rank = rank,
                rankIndex = rankIndex,
                hours = hoursNum,
                hoursText = hoursText,
                hasRank = rank ~= "No Rank"
            })
        end
    end
    
    -- Sort by rank first (highest first), then by hours (highest first)
    table.sort(aegisPlayers, function(a, b)
        -- Players with ranks come before players without ranks
        if a.hasRank ~= b.hasRank then
            return a.hasRank
        end
        
        if a.rankIndex ~= b.rankIndex then
            return a.rankIndex < b.rankIndex
        end
        return a.hours > b.hours
    end)
    
    -- Create 3-column grid
    local column = 0
    local row = 0
    
    for i, data in ipairs(aegisPlayers) do
        local plr = data.player
        local rank = data.rank
        local rankColor = getRankColor(rank)
        local rankAbbrev = getRankAbbrev(rank)
        local hoursText = data.hoursText
        local hasRank = data.hasRank
        
        -- Calculate position (3 columns)
        column = (i - 1) % 3
        row = math.floor((i - 1) / 3)
        
        -- Create button frame (clickable) - compact 60px height
        local button = Instance.new("TextButton")
        button.Position = UDim2.new(column * 0.333, column * 5 + 5, 0, row * 65 + 5)
        button.Size = UDim2.new(0.333, -10, 0, 60)
        button.BackgroundColor3 = Color3.fromRGB(34, 34, 40)
        button.BorderSizePixel = 0
        button.AutoButtonColor = false
        button.Text = ""
        button.ZIndex = 5
        button.Parent = State.gridFrame
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = button
        
        local stroke = Instance.new("UIStroke")
        stroke.Color = hasRank and rankColor or Color3.fromRGB(100, 100, 110)
        stroke.Transparency = 0.7
        stroke.Thickness = 1.5
        stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        stroke.Parent = button
        
        -- Player name (top)
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Position = UDim2.new(0, 5, 0, 5)
        nameLabel.Size = UDim2.new(1, -10, 0, 16)
        nameLabel.BackgroundTransparency = 1
        nameLabel.Font = Enum.Font.GothamBold
        nameLabel.Text = plr.Name
        nameLabel.TextColor3 = Color3.fromRGB(240, 240, 245)
        nameLabel.TextSize = 11
        nameLabel.TextXAlignment = Enum.TextXAlignment.Center
        nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
        nameLabel.ZIndex = 6
        nameLabel.Parent = button
        
        -- Rank (middle) - only show if player has rank
        if hasRank then
            local rankLabel = Instance.new("TextLabel")
            rankLabel.Position = UDim2.new(0, 5, 0, 24)
            rankLabel.Size = UDim2.new(1, -10, 0, 14)
            rankLabel.BackgroundTransparency = 1
            rankLabel.Font = Enum.Font.GothamBold
            rankLabel.Text = rankAbbrev
            rankLabel.TextColor3 = rankColor
            rankLabel.TextSize = 10
            rankLabel.ZIndex = 6
            rankLabel.Parent = button
        end
        
        -- Hours (bottom)
        local hoursLabel = Instance.new("TextLabel")
        hoursLabel.Position = UDim2.new(0, 5, 0, hasRank and 41 or 28)
        hoursLabel.Size = UDim2.new(1, -10, 0, 14)
        hoursLabel.BackgroundTransparency = 1
        hoursLabel.Font = Enum.Font.Gotham
        hoursLabel.Text = hoursText
        hoursLabel.TextColor3 = Color3.fromRGB(150, 150, 160)
        hoursLabel.TextSize = 9
        hoursLabel.ZIndex = 6
        hoursLabel.Parent = button
        
        -- Highlight if currently spectating this player
        if State.spectating and State.targetPlayer == plr then
            button.BackgroundColor3 = Color3.fromRGB(54, 44, 60)
            stroke.Transparency = 0.3
        end
        
        -- Hover effects
        button.MouseEnter:Connect(function()
            if not (State.spectating and State.targetPlayer == plr) then
                TweenService:Create(button, TweenInfo.new(0.2), {
                    BackgroundColor3 = Color3.fromRGB(44, 44, 50)
                }):Play()
            end
            TweenService:Create(stroke, TweenInfo.new(0.2), {
                Transparency = 0.4
            }):Play()
        end)
        
        button.MouseLeave:Connect(function()
            if not (State.spectating and State.targetPlayer == plr) then
                TweenService:Create(button, TweenInfo.new(0.2), {
                    BackgroundColor3 = Color3.fromRGB(34, 34, 40)
                }):Play()
            end
            TweenService:Create(stroke, TweenInfo.new(0.2), {
                Transparency = 0.7
            }):Play()
        end)
        
        -- Click to spectate
        button.MouseButton1Click:Connect(function()
            if State.spectating and State.targetPlayer == plr then
                -- Stop spectating if clicking same player
                stopSpectate()
                createPlayerList()  -- Refresh to remove highlight
            else
                -- Spectate this player
                spectatePlayer(plr)
                createPlayerList()  -- Refresh to show highlight
            end
        end)
        
        State.playerButtons[plr.UserId] = button
    end
    
    -- Update canvas size
    local totalRows = math.ceil(#aegisPlayers / 3)
    State.gridFrame.CanvasSize = UDim2.new(0, 0, 0, totalRows * 65 + 10)
end

--==============================================================================
--                          CREATE UI
--==============================================================================

-- Create grid frame for player list (3 columns)
do
    local scrollFrame = Instance.new("ScrollingFrame")
    scrollFrame.Size = UDim2.new(1, 0, 1, 0)
    scrollFrame.BackgroundTransparency = 1
    scrollFrame.BorderSizePixel = 0
    scrollFrame.ScrollBarThickness = 6
    scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(138, 43, 226)
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    scrollFrame.ZIndex = 4
    scrollFrame.Parent = page
    
    State.gridFrame = scrollFrame
end

-- Initial player list
createPlayerList()

-- Update on player join/leave
Players.PlayerAdded:Connect(function()
    task.wait(1)
    createPlayerList()
end)

Players.PlayerRemoving:Connect(function()
    createPlayerList()
end)

-- Refresh every 5 seconds (to update hours)
task.spawn(function()
    while true do
        task.wait(5)
        createPlayerList()
    end
end)

-- Stop spectating when player character respawns
player.CharacterAdded:Connect(function()
    if State.spectating then
        stopSpectate()
        createPlayerList()
    end
end)

print("✓ Wastelander Spectate Module Loaded")

-- Expose stopSpectate globally for teleport module
_G.WastelanderHub.stopSpectate = stopSpectate

return true
